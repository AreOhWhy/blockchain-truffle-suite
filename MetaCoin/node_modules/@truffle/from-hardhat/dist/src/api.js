"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.IncompatibleHardhatBuildInfoFormatError = exports.prepareCompilations = exports.prepareConfig = exports.IncompatibleHardhatVersionError = exports.NotHardhatError = exports.expectHardhat = void 0;
const fs_1 = require("fs");
const semver_1 = __importDefault(require("semver"));
const constants_1 = require("./constants");
const Compilation = __importStar(require("./compilation"));
const Config = __importStar(require("./config"));
const ask_hardhat_1 = require("./ask-hardhat");
/**
 * Checks for the existence of a Hardhat project configuration and asserts
 * that the local installed version of Hardhat matches this package's
 * supported version range.
 *
 * @param options to control process environment (e.g. working directory)
 * @return Promise<void> when expectation holds
 * @throws NotHardhatError when not in a Hardhat project directory
 * @throws IncompatibleHardhatError if Hardhat has unsupported version
 */
const expectHardhat = (options) => __awaiter(void 0, void 0, void 0, function* () {
    const isHardhat = yield (0, ask_hardhat_1.checkHardhat)(options);
    if (!isHardhat) {
        throw new NotHardhatError();
    }
    const hardhatVersion = yield (0, ask_hardhat_1.askHardhatVersion)(options);
    if (!semver_1.default.satisfies(hardhatVersion, constants_1.supportedHardhatVersionRange)) {
        throw new IncompatibleHardhatVersionError(hardhatVersion);
    }
});
exports.expectHardhat = expectHardhat;
/**
 * Thrown when no Hardhat project is found
 */
class NotHardhatError extends Error {
    constructor() {
        super("Current working directory is not part of a Hardhat project");
    }
}
exports.NotHardhatError = NotHardhatError;
/**
 * Thrown when Hardhat was detected but with an incompatible version
 */
class IncompatibleHardhatVersionError extends Error {
    constructor(detectedVersion) {
        super(`Expected Hardhat version compatible with ${constants_1.supportedHardhatVersionRange}, got: ${detectedVersion}`);
    }
}
exports.IncompatibleHardhatVersionError = IncompatibleHardhatVersionError;
/**
 * Constructs a @truffle/config object based on the Hardhat config.
 *
 * WARNING: except for fields documented here, the values present on the
 * returned @truffle/config object MUST be regarded as unsafe to use.
 *
 * The returned `config` is defined to contain the following:
 *
 *   - `config.networks` with configurations for all Hardhat-configured
 *     networks, provided:
 *       - The configured network is not the built-in `hardhat` network
 *       - The configured network defines a `url` property
 *
 *     Note: this function ignores all properties other than `url`,
 *     including any information that can be used for computing
 *     cryptographic signatures. THIS FUNCTION DOES NOT READ PRIVATE KEYS.
 *
 * Suffice to say:
 *
 * THIS FUNCTION'S BEHAVIOR IS EXPERIMENTAL AND SHOULD ONLY BE USED IN
 * SPECIFICALLY KNOWN-SUPPORTED USE CASES (like reading for configured
 * network urls)
 *
 * @param options to control process environment (e.g. working directory)
 * @return Promise<TruffleConfig>
 *
 * @dev This function shells out to `npx hardhat console` to ask the Hardhat
 *      runtime environment for the Hardhat config info that Truffle needs.
 */
const prepareConfig = (options) => __awaiter(void 0, void 0, void 0, function* () {
    // define a function to grab only the networks and fields we need.
    //
    // this duplicates the transformation behavior in src/config.ts for safe
    // measure, since these two components may differ in requirements in the
    // future.
    const extractNetworks = (hre) => ({
        networks: Object.entries(hre.config.networks)
            .filter((pair) => pair[0] !== "hardhat" && "url" in pair[1])
            .map(([networkName, { url }]) => ({
            [networkName]: { url }
        }))
            .reduce((a, b) => (Object.assign(Object.assign({}, a), b)), {})
    });
    const hardhatConfig = (yield (0, ask_hardhat_1.askHardhatConsole)(
    // stringify the function hooray
    `(${extractNetworks.toString()})(hre)`, options));
    return Config.fromHardhatConfig(hardhatConfig);
});
exports.prepareConfig = prepareConfig;
/**
 * Constructs an array of @truffle/compile-common `Compilation` objects
 * corresponding one-to-one with Hardhat's persisted results of each solc
 * compilation.
 *
 * WARNING: this function only supports Hardhat projects written entirely
 * in solc-compatible languages (Solidity, Yul). Behavior of this function
 * for Hardhat projects using other languages is undefined.
 *
 * @param options to control process environment (e.g. working directory)
 * @return Promise<Compilation[]> from @truffle/compile-common
 *
 * @dev This function shells out to `npx hardhat console` to ask the Hardhat
 *      runtime environment for the location of the project build info
 *      files
 */
const prepareCompilations = (options) => __awaiter(void 0, void 0, void 0, function* () {
    const compilations = [];
    const buildInfoPaths = (yield (0, ask_hardhat_1.askHardhatConsole)(`artifacts.getBuildInfoPaths()`, options));
    for (const buildInfoPath of buildInfoPaths) {
        const buildInfo = JSON.parse((yield fs_1.promises.readFile(buildInfoPath)).toString());
        const { _format } = buildInfo;
        if (!constants_1.supportedHardhatBuildInfoFormats.has(_format)) {
            throw new IncompatibleHardhatBuildInfoFormatError(_format);
        }
        const compilation = Compilation.fromBuildInfo(buildInfo);
        compilations.push(compilation);
    }
    return compilations;
});
exports.prepareCompilations = prepareCompilations;
/**
 * Thrown when the build-info format detected has an incompatible version
 */
class IncompatibleHardhatBuildInfoFormatError extends Error {
    constructor(detectedFormat) {
        super(`Expected build-info to be one of ["${[
            ...constants_1.supportedHardhatBuildInfoFormats
        ].join('", "')}"], got: "${detectedFormat}"`);
    }
}
exports.IncompatibleHardhatBuildInfoFormatError = IncompatibleHardhatBuildInfoFormatError;
//# sourceMappingURL=api.js.map