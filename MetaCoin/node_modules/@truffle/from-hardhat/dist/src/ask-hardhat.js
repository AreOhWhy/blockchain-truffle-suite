"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.askHardhatConsole = exports.askHardhatVersion = exports.checkHardhat = void 0;
const child_process_1 = require("child_process");
const find_up_1 = __importDefault(require("find-up"));
const constants_1 = require("./constants");
const options_1 = require("./options");
/**
 * Returns a Promise to a boolean that is true if and only if
 * the detected or specified environment is part of a Hardhat project.
 *
 * (i.e., if the working directory or any of its parents has a Hardhat config)
 */
const checkHardhat = (options) => __awaiter(void 0, void 0, void 0, function* () {
    const { workingDirectory } = (0, options_1.withDefaultEnvironmentOptions)(options);
    // search recursively up for a hardhat config
    const hardhatConfigPath = yield (0, find_up_1.default)(constants_1.validHardhatConfigFilenames, {
        cwd: workingDirectory
    });
    return !!hardhatConfigPath;
});
exports.checkHardhat = checkHardhat;
/**
 * Reads version information via `npx hardhat --version`
 */
const askHardhatVersion = (options) => __awaiter(void 0, void 0, void 0, function* () {
    return new Promise((accept, reject) => {
        const { workingDirectory } = (0, options_1.withDefaultEnvironmentOptions)(options);
        const hardhat = (0, child_process_1.spawn)(`npx`, ["hardhat", "--version"], {
            stdio: ["pipe", "pipe", "inherit"],
            cwd: workingDirectory,
            shell: true
        });
        let output = "";
        hardhat.stdout.on("data", data => {
            output = `${output}${data}`;
        });
        hardhat.once("close", code => {
            if (code !== 0) {
                return reject(new Error(`Hardhat exited with non-zero code ${code}`));
            }
            return accept(output);
        });
    });
});
exports.askHardhatVersion = askHardhatVersion;
const askHardhatConsole = (expression, _a = {}) => __awaiter(void 0, void 0, void 0, function* () {
    var { raw = false } = _a, options = __rest(_a, ["raw"]);
    return new Promise((accept, reject) => {
        const { workingDirectory } = (0, options_1.withDefaultEnvironmentOptions)(options);
        // Latin-1 Supplemental block control codes
        const sos = String.fromCodePoint(0x0098); // start of string
        const st = String.fromCodePoint(0x009c); // string terminator
        const prefix = `${sos}truffle-start${st}`;
        const suffix = `${sos}truffle-end${st}`;
        // note the hardhat console instance is spawned with --no-compile which causes it to skip the initial (default) compilation step
        const hardhat = (0, child_process_1.spawn)(`npx`, ["hardhat", "console", "--no-compile"], {
            stdio: ["pipe", "pipe", "inherit"],
            cwd: workingDirectory,
            shell: true
        });
        // we'll capture the stdout
        let output = "";
        hardhat.stdout.on("data", data => {
            output = `${output}${data}`;
        });
        // setup close event before writing to stdin because we're sending eof
        hardhat.once("close", code => {
            if (code !== 0) {
                return reject(new Error(`Hardhat exited with non-zero code ${code}`));
            }
            const data = output.slice(output.indexOf(prefix) + prefix.length, output.indexOf(suffix));
            if (raw) {
                return accept(data);
            }
            try {
                const result = JSON.parse(data);
                return accept(result);
            }
            catch (error) {
                return reject(error);
            }
        });
        // write to stdin to ask for requested data. this does a few things:
        // - wrap the expression into something that resolves as a Promise.
        //   this ensures that we can handle raw synchronous expressions as well
        //   as Promise-returning expressions.
        // - write the resolved value to the console, using the prefix/suffix
        //   sentinels to ensure Truffle knows what stdout comes from this process,
        //   vs. whatever stdout Hardhat may produce on its own.
        // - unless `raw` is turned on, stringify the resolved value as JSON.
        hardhat.stdin.write(`
      Promise.resolve(${expression})
        .then(${raw
            ? `(resolved) => console.log(
                \`${prefix}$\{resolved}${suffix}\`
              )`
            : `(resolved) => console.log(
                \`${prefix}$\{JSON.stringify(resolved)}${suffix}\`
              )`})
    `);
        hardhat.stdin.end();
    });
});
exports.askHardhatConsole = askHardhatConsole;
//# sourceMappingURL=ask-hardhat.js.map